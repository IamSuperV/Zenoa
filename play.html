<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playing - ZENOA</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .option-btn {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            padding: 1rem;
            text-align: left;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-primary);
            font-size: 1rem;
            user-select: none;
            /* Prevent text selection on rapid clicks */
        }

        .option-btn:hover {
            background-color: var(--surface-hover);
            border-color: var(--accent-color);
        }

        .option-btn.selected {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            font-weight: 600;
        }
    </style>
</head>

<body>
    <div class="container" style="max-width: 800px; padding-top: 2rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
            <div style="font-weight: 700; color: var(--text-secondary);">ZENOA</div>
            <div id="timer" style="font-variant-numeric: tabular-nums; font-weight: 700; font-size: 1.2rem;">Live</div>
        </div>

        <div class="card">
            <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                <span id="category-badge"
                    style="background: var(--surface-hover); padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.8rem; text-transform: uppercase;">...</span>
                <span id="progress-indicator">1 / 8</span>
            </div>

            <h2 id="scenario-text" style="font-size: 1.5rem; margin-bottom: 2rem; line-height: 1.4;">Loading scenario...
            </h2>

            <div id="options-container" style="display: flex; flex-direction: column; gap: 1rem;">
                <!-- Options injected here -->
            </div>
            <p id="error-msg" style="color: var(--danger-color); text-align: center; margin-top: 1rem;"></p>
        </div>

        <div id="next-btn-container" style="margin-top: 2rem; text-align: center;">
            <button id="next-btn" class="btn btn-primary" style="padding: 0.5rem 2rem;">Next Question</button>
        </div>
        <p id="waiting-msg" class="hidden"
            style="text-align: center; margin-top: 2rem; color: var(--text-secondary); font-style: italic;">Waiting for
            host...</p>
    </div>

    <script type="module">
        import { auth } from './js/firebase.js';
        import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.2.0/firebase-auth.js";
        import { subscribeToGame, submitAnswer, nextQuestion } from './js/game.js';
        import { QUESTIONS_DB } from './js/data.js';

        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('roomId');

        if (!roomId) window.location.href = 'dashboard.html';

        let currentUser = null;
        let currentRoomData = null;
        let localCurrentIndex = 0;
        let totalQuestions = 0;

        // 1. Start fetching room IMMEDIATELY (Do not wait for Auth)
        initGameListener();

        // 2. Check Auth in parallel
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                // If not logged in, we can still show the question (read-only) 
                // but eventually they need to login. 
                // For now, let's redirect if strictly required, or better:
                // Let them see the text, but clicking options redirects to login.
                // But existing logic redirects. Let's keep redirect but maybe delay it?
                // Actually, if they are mid-game, they should be logged in.
                // Sticking to redirect providing safety, but the room load starts anyway.
                window.location.href = 'login.html';
            } else {
                currentUser = user;
                // If room data is already here, re-render to show selected answers (if any)
                if (currentRoomData) {
                    renderQuestion(currentRoomData);
                }
            }
        });

        function initGameListener() {
            console.log("Fetching room...");
            subscribeToGame(roomId, (roomData) => {
                if (!roomData) {
                    console.error("Room not found or empty data");
                    document.getElementById('scenario-text').textContent = "Error: Room not found.";
                    return;
                }
                currentRoomData = roomData;
                totalQuestions = roomData.questionQueue ? roomData.questionQueue.length : 0;

                // Render immediately (even if user is null temporarily)
                renderQuestion(roomData);
            });
        }

        function renderQuestion(roomData) {
            const index = localCurrentIndex;

            // Debugging
            if (!roomData.questionQueue || roomData.questionQueue.length === 0) {
                document.getElementById('scenario-text').textContent = "Error: This room has no questions.";
                return;
            }

            // Check if finished
            if (index >= totalQuestions) {
                window.location.href = `results.html?roomId=${roomId}`;
                return;
            }

            const qId = roomData.questionQueue[index];
            const question = QUESTIONS_DB.find(q => q.id === qId);

            if (!question) {
                console.error("Missing Question ID:", qId);
                document.getElementById('scenario-text').textContent = `Error: Question details not found (${qId})`;
                document.getElementById('category-badge').textContent = "Error";

                // Auto-skip?
                // document.getElementById('next-btn-container').classList.remove('hidden');
                return;
            }

            // Update UI Labels
            document.getElementById('category-badge').textContent = question.category;
            document.getElementById('progress-indicator').textContent = `${index + 1} / ${totalQuestions}`;
            document.getElementById('scenario-text').textContent = question.scenario;

            // Determine Selected Answer
            // If user is not loaded yet, we just don't show selection (it will update when Auth loads)
            let savedAnswer = undefined;
            if (currentUser && roomData.answers && roomData.answers[currentUser.uid]) {
                savedAnswer = roomData.answers[currentUser.uid][String(qId)];
            }

            // Render Options
            const container = document.getElementById('options-container');
            container.innerHTML = '';

            question.options.forEach((opt, i) => {
                const btn = document.createElement('div');
                btn.className = 'option-btn';
                btn.textContent = opt;

                // Active State
                if (savedAnswer === i) {
                    btn.classList.add('selected');
                }

                // Click Handler
                btn.onclick = async () => {
                    if (!currentUser) return; // Ignore clicks if auth not ready

                    // Optimistic UI update
                    const allBtns = container.querySelectorAll('.option-btn');
                    allBtns.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');

                    try {
                        await submitAnswer(roomId, currentUser.uid, qId, i);
                        document.getElementById('error-msg').textContent = '';

                        // Auto-advance or Enable Next? 
                        // Let's enable the Next button logic.
                        // Actually, user clicked default next button before.
                        // We will keep it simple.
                        document.getElementById('next-btn-container').classList.remove('hidden');
                    } catch (e) {
                        document.getElementById('error-msg').textContent = "Failed to save answer. Try again.";
                        btn.classList.remove('selected');
                    }
                };

                container.appendChild(btn);
            });

            // Show Next Button if already answered (or allow anyway)
            document.getElementById('next-btn-container').classList.remove('hidden');
        }

        // Universal Next Button Logic
        const nextBtn = document.getElementById('next-btn');
        nextBtn.addEventListener('click', () => {
            localCurrentIndex++;
            // Force re-render with new index
            renderQuestion(currentRoomData);
            // Hide button until they answer next one (optional, but good UX)
            // But existing code showed it always in host controls.
            // We will keep it simple.
            window.scrollTo(0, 0);
        });
    </script>
</body>

</html>